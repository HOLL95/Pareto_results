<!DOCTYPE html>
<html lang="en">
<head>
    <script>
    window.MathJax = {
        tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        startup: {
        ready: () => {
            console.log('MathJax is loaded and ready.');
            MathJax.startup.defaultReady();
        }
        }
    };
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dygraph/2.2.1/dygraph.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dygraph/2.2.1/dygraph.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M4D2 Results</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" type="text/css" href="styles.css">
    
</head>
<body>
    <div class="container">
        <h1>Multi-Objective Pareto Matrix Visualizer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="colormap">Color Map:</label>
                <select id="colormap">
                    <option value="viridis">Viridis</option>
                    <option value="plasma">Plasma</option>
                    <option value="inferno">Inferno</option>
                    <option value="magma">Magma</option>
                    <option value="cool">Cool</option>
                    <option value="warm">Warm</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="turbo">Turbo</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="colormapping">Color Mapping:</label>
                <select id="colormapping">
                </select>
            </div>
        </div>

        <div class="matrix-container">
            <svg id="matrix-plot"></svg>
        </div>

        <div class="info-panel">
            <h3>Multi-Objective Pareto Front Explorer</h3>
            <p><strong>Click on any point</strong> to highlight it across all subplots and see detailed information.</p>
            <p><strong>Hover over points</strong> to see values for that 2D projection.</p>
            <p><strong>Each subplot</strong> shows a different pair of objectives from the multi-dimensional Pareto front.</p>
            
            <div class="stats-panel" id="statsPanel"></div>
            <div class="color-legend" id="colorLegend"></div>
        </div>
        <div id="dataGridContainer"></div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script type="module">
        import { loadDataFile ,joinPath} from './dataLoader.js';
        import {createCellWithDygraph, updateDataGrid, addSimulationTraceToCharts} from "./dygraph_handler.js"
        import init, * as wasm from 'https://holl95.github.io/Pareto_results/biquad_wasm/pkg/biquad_wasm.js';
        await init('https://holl95.github.io/Pareto_results/biquad_wasm/pkg/biquad_wasm_bg.wasm');
        const parameters = await loadDataFile('M4D2/Scores/pareto_parameters.txt');
        const scores = await loadDataFile('M4D2/Scores/Colour_scores.txt');
        const raw_scores=await loadDataFile('M4D2/Scores/scores.txt');
        let isSimulationLoading = false;
        let isPlottingInProgress = false;
        export const dygraphInstances = [];
        let traceCounter = 0;
        const matrixContainer = document.querySelector('.matrix-container');
        const width = matrixContainer.offsetWidth;
        const numObjectives=parameters.headers.length-1;
        const subplotSize = width/(numObjectives-1+(0.1*(numObjectives-1)));
        const subplotPadding = subplotSize*0.1;
        const colormapSelect = document.getElementById('colormap');
        const colormappingSelect = document.getElementById('colormapping');
        const options_map=scores.headers.map((name, index) => ({
                                            value: index,
                                            label: name,
                                            }));
        
        const label_map={'E0_mean': '$E^0 \\mu$ (V)', 
                        'E0_std_1': '$E^0 \\sigma_{FTACV}$ (V)', 
                        'E0_std_2': '$E^0 \\sigma_{SWV}$ (V)', 
                        'k0': '$k_0$ ($s^{-1}$)', 
                        'gamma_1': '$\\Gamma_{FTACV}$ (mol cm$^{-2}$)', 
                        'gamma_2': '$\\Gamma_{SWV}$ (mol cm$^{-2}$)', 
                        'Ru': '$R_u$ ($\\Omega$)', 
                        'Cdl': '$C_{dl}$ (F cm$^{-2}$)', 
                        'alpha': '$\\alpha$'}
        const unicode_map = {
                        'E0_mean': 'E⁰ μ (V)',
                        'E0_std_1': 'E⁰ σₐᵥ (V)',
                        'E0_std_2': 'E⁰ σₛᵥ (V)', 
                        'k0': 'k₀ (s⁻¹)',
                        'gamma_1': 'Γₐᵥ (mol cm⁻²)',
                        'gamma_2': 'Γₛᵥ(mol cm⁻²)',
                        'Ru': 'Rᵤ (Ω)',
                        'Cdl': 'C (F cm⁻²)',
                        'alpha': 'α'
                    };
        const files=["FTACV-3_Hz-280_mV","FTACV-9_Hz-280_mV","FTACV-15_Hz-280_mV",
                    'SWV-65_Hz-anodic', 'SWV-65_Hz-cathodic', 
                    'SWV-75_Hz-anodic', 'SWV-75_Hz-cathodic',
                     'SWV-85_Hz-anodic', 'SWV-85_Hz-cathodic',
                      'SWV-100_Hz-anodic', 'SWV-100_Hz-cathodic',
                       'SWV-115_Hz-anodic', 'SWV-115_Hz-cathodic', 
                       'SWV-125_Hz-anodic', 'SWV-125_Hz-cathodic', 
                       'SWV-135_Hz-anodic', 'SWV-135_Hz-cathodic', 
                       'SWV-145_Hz-anodic', 'SWV-145_Hz-cathodic', 
                       'SWV-150_Hz-anodic', 'SWV-150_Hz-cathodic', 
                       'SWV-175_Hz-anodic', 'SWV-175_Hz-cathodic', 
                       'SWV-200_Hz-anodic', 'SWV-200_Hz-cathodic', 
                       'SWV-300_Hz-anodic', 'SWV-300_Hz-cathodic']
        const simulations_map={};
        let file_counter=0;
        let start, end;
        for (let i=0; i<213; i++){
            simulations_map[i]={
                loaded:false,
                data:{}
            }
            if ((i%2)==0){
                start=i;
                end=i+2;
                
            }else{
                start=i-1;
                end=i+1;
            }
            simulations_map[i].file=`simulations_${start}_${end}.txt`;
            for (let j=0; j<files.length; j++){
                simulations_map[i].data[files[j]]={};
            }
        }
        
        const initialDataSets = await Promise.all(
                                        files.map(async (name, index) => ({
                                            name: name,
                                            data: (await loadDataFile(joinPath("./M4D2", "Data", name, "data.txt"))).data,
                                            times: (await loadDataFile(joinPath("./M4D2", "Data", name, "times.txt"))).data,
                                        }))
                                        );
        


        const format_params = new Set(["gamma_1", "gamma_2", "Cdl"]); // Use Set for faster lookup

        const formatters = Object.fromEntries(
                            parameters.headers.map(name => [
                                name, 
                                x => format_params.has(x) ? d3.format(".1e")(x) : x
                            ])
                            );

        // Clear existing options
        colormappingSelect.innerHTML = '';
        
        // Add colormap options
        options_map.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.label;
            colormappingSelect.appendChild(opt);
        });
        // Multi-dimensional Pareto points data
        
        let selectedPointIds = [];

        // Color scales
        const colorMaps = {
            viridis: d3.interpolateViridis,
            plasma: d3.interpolatePlasma,
            inferno: d3.interpolateInferno,
            magma: d3.interpolateMagma,
            cool: d3.interpolateCool,
            warm: d3.interpolateWarm,
            rainbow: d3.interpolateRainbow,
            turbo: d3.interpolateTurbo
        };

        // Matrix layout parameters
        const matrixMargin = {top: 40, right: 20, bottom: 40, left: 60};
        const paretoPoints = parameters.data.map((objectives, index) => ({
                                            id: index,
                                            objectives: objectives
                                            }));
        
        // Create main SVG
        const svg = d3.select("#matrix-plot");
        const tooltip = d3.select("#tooltip");

        updateColorMappingOptions();
        updateMatrix();
        

        

        function updateColorMappingOptions() {
            const select = document.getElementById('colormapping');
            const currentValue = select.value;
            
            // Clear existing objective options
            Array.from(select.options).forEach(option => {
                if(option.value.startsWith('obj')) {
                    option.remove();
                }
            });
            
            
          
            select.value = currentValue;
            
        }

        function calculateColorValue(point, mapping) {
            //console.log(mapping)
            return scores.data[point.id][mapping];
        }

        function updateMatrix() {
            if(paretoPoints.length === 0) return;
            
            const colormap = document.getElementById('colormap').value;
            const colormapping = document.getElementById('colormapping').value;

            // Calculate matrix dimensions
            const matrixSize = numObjectives - 2;
            const totalWidth = matrixSize * (subplotSize + subplotPadding) + matrixMargin.left + matrixMargin.right;
            const totalHeight = matrixSize * (subplotSize + subplotPadding) + matrixMargin.top + matrixMargin.bottom;

            // Update SVG size
            svg.attr("width", totalWidth)
               .attr("height", totalHeight);

            // Clear previous content
            svg.selectAll("*").remove();

            const mainG = svg.append("g")
                .attr("transform", `translate(${matrixMargin.left},${matrixMargin.top})`);

            // Calculate color values
            const colorValues = paretoPoints.map(d => calculateColorValue(d, colormapping));
            const colorScale = d3.scaleSequential(colorMaps[colormap])
                .domain(d3.extent(colorValues));

            // Create subplots for lower triangular matrix
            for(let row = 0; row < numObjectives-1; row++) {
                for(let col = 0; col < row; col++) {
                    createSubplot(mainG, row, col, colorScale, colormapping);
                }
            }
            createPolarPlot(mainG);

            updateColorLegend(colorScale, colormapping);
            updateStats([])
            updateDataGrid(initialDataSets,dygraphInstances);
        }
        function createPolarPlot(parent) {
            const xPos = Math.floor(numObjectives*9/16) * (subplotSize + subplotPadding);
            const yPos =  (subplotSize + subplotPadding);
            const polarG = parent.append("g")
                .attr("class", "polar-subplot")
                .attr("transform", `translate(${xPos + subplotSize},${yPos + subplotSize})`);

            const radius = (subplotSize);
            
            // Create background circle
            polarG.append("circle")
                .attr("r", radius)
                .attr("fill", "white")
                .attr("stroke", "#e0e0e0")
                .attr("stroke-width", 1);

            // Create radial grid lines
            const numGridLines = 4;
            for(let i = 1; i <= numGridLines; i++) {
                polarG.append("circle")
                    .attr("r", (radius * i) / numGridLines)
                    .attr("fill", "none")
                    .attr("stroke", "#f0f0f0")
                    .attr("stroke-width", 0.5);
            }

            // Add metric axes (spokes)
            const numMetrics = raw_scores.headers.length;
            const angleStep = (2 * Math.PI) / numMetrics;
            
            raw_scores.headers.forEach((metric, i) => {
                const angle = i * angleStep - Math.PI/2; // Start from top
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                // Draw spoke
                polarG.append("line")
                    .attr("x1", 0).attr("y1", 0)
                    .attr("x2", x).attr("y2", y)
                    .attr("stroke", "#e0e0e0")
                    .attr("stroke-width", 1);
                
                // Add label
                const labelRadius = radius + 15;
                const labelX = Math.cos(angle) * labelRadius;
                const labelY = Math.sin(angle) * labelRadius;
                
                polarG.append("text")
                    .attr("x", labelX)
                    .attr("y", labelY)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "central")
                    .attr("font-size", "12px")
                    .attr("fill", "#666")
                    .text(metric);
            });

            // Store reference for updates
            //polarG.attr("data-row", row).attr("data-col", col);
        }
        function updatePolarPlots(selectedPoints) {
            const polarG = d3.select(".polar-subplot");
            if(!selectedPoints) {
                // Clear the polar plot
                polarG.selectAll(".data-polygon, .data-point").remove();
                return;
            }
            let selectedPoint;
            let colours=['#ff7f0e' ,"#2ca02c"];
            let transparents=["rgba(255, 127, 14, 0.3)","rgba(44, 160, 44, 0.3)"]
            polarG.selectAll("[class*='data-polygon'], [class*='data-point']").remove();
            for (let i=0; i<selectedPoints.length; i++){
                selectedPoint=selectedPoints[i]
                const radius = subplotSize;
                const scoreData = raw_scores.data[selectedPoint.id];
                const numMetrics = raw_scores.headers.length;
                const angleStep = (2 * Math.PI) / numMetrics;

                // Remove old data
               

                // Create data points (scores are already normalized)
                const dataPoints = raw_scores.headers.map((header, i) => {
                    const angle = i * angleStep - Math.PI/2;
                    const normalizedValue = 1-scoreData[i]; // Already normalized
                    const r = normalizedValue * radius;
                    return {
                        x: Math.cos(angle) * r,
                        y: Math.sin(angle) * r,
                        value: scoreData[i],
                        metric: header
                    };
                });

                // Create polygon path
                const line = d3.line()
                    .x(d => d.x)
                    .y(d => d.y)
                    .curve(d3.curveLinearClosed);

                polarG.append("path")
                    .datum(dataPoints)
                    .attr("class", "data-polygon")
                    .attr("d", line)
                    .attr("fill", transparents[i])
                    .attr("stroke", colours[i])
                    .attr("stroke-width", 2);

                // Add data points
                polarG.selectAll(`.data-point-${i}`)
                    .data(dataPoints)
                    .enter()
                    .append("circle")
                    .attr("class", `data-point data-point-${i}`)
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y)
                    .attr("r", 3)
                    .attr("fill", colours[i])
                    .attr("stroke", "white")
                    .attr("stroke-width", 1)
                    .on("mouseover", function(event, d) {
                        tooltip.style("opacity", 1)
                            .html(`<strong>${d.metric}</strong><br/>Score: ${(100*(1-d.value)).toFixed(1)}%`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.style("opacity", 0);
                    });
                }
            
        }
        function createSubplot(parent, row, col, colorScale, colormapping) {
            const xPos = col * (subplotSize + subplotPadding);
            const yPos = (row-1) * (subplotSize + subplotPadding);
            const subplotG = parent.append("g")
                .attr("class", "subplot")
                .attr("transform", `translate(${xPos},${yPos})`);

            // Create background
            subplotG.append("rect")
                .attr("width", subplotSize)
                .attr("height", subplotSize)
                .attr("fill", "white")
                .attr("stroke", "#e0e0e0")
                .attr("stroke-width", 1)
                .attr("rx", 4);

            // Create scales for this subplot
            const xData = paretoPoints.map(d => d.objectives[col]);
            const yData = paretoPoints.map(d => d.objectives[row]);
            
            const xScale = d3.scaleLinear()
                .domain(d3.extent(xData))
                .range([20, subplotSize - 20])
                .nice();
                
            const yScale = d3.scaleLinear()
                .domain(d3.extent(yData))
                .range([subplotSize - 20, 20])
                .nice();
            let xAxis;
            let yAxis;
            xAxis = d3.axisBottom(xScale).ticks(3).tickSize(-subplotSize + 40).tickFormat(formatters[parameters.headers[col + 1]]);
            yAxis = d3.axisLeft(yScale).ticks(3).tickSize(-subplotSize + 40).tickFormat(formatters[parameters.headers[row + 1]]);
            subplotG.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${subplotSize - 20})`)
                .call(xAxis)
                .selectAll(".tick line")
                .attr("stroke", "#f0f0f0");

            subplotG.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(20,0)")
                .call(yAxis)
                .selectAll(".tick line")
                .attr("stroke", "#f0f0f0");

            // Add axis labels
            if (row==numObjectives-2){
                 subplotG.append("foreignObject")
                .attr("x", subplotSize / 2 -50)  // Adjust width as needed
                .attr("y", subplotSize + 5)
                .attr("width", 120)
                .attr("height", 20)
                .append("xhtml:div")
                .style("text-align", "center")
                .style("font-size", "11px")
                .style("font-weight", "600")
                .style("color", "#666")
                .html(label_map[parameters.headers[col + 1]]);
            
            // Trigger MathJax rendering
            MathJax.typesetPromise();

               
            }
           
            if (col==0){
                subplotG.append("foreignObject")
                .attr("x", -150)  // Adjust width as needed
                .attr("y", -50)
                .attr("width", 120)
                .attr("height", 20)
                .attr("transform", "rotate(-90)")
                .append("xhtml:div")
                .style("text-align", "center")
                .style("font-size", "11px")
                .style("font-weight", "600")
                .style("color", "#666")
                .html(label_map[parameters.headers[row+1]]);
            }


            // Add points
            const points = subplotG.selectAll(".point")
                .data(paretoPoints)
                .enter()
                .append("circle")
                .attr("class", "point")
                .attr("cx", d => xScale(d.objectives[col]))
                .attr("cy", d => yScale(d.objectives[row]))
                .attr("r", 2.5)
                .attr("fill", d => colorScale(calculateColorValue(d, colormapping)))
                .classed("selected", d => selectedPointIds.includes(d.id))
                .classed("selected-first", d => selectedPointIds[0] === d.id)
                .classed("selected-second", d => selectedPointIds[1] === d.id)
                .on("click", async function(event, d) {
                    // Ignore clicks if already processing
                    if (isSimulationLoading || isPlottingInProgress) {
                        console.log("Processing in progress");
                        return;
                    }
                    
                    try {
                        // Set loading state
                        isSimulationLoading = true;
                        
                        // Update UI to show loading state (optional)
                        d3.select(this).classed("loading", true);
                        
                        // Update selection state for two points
                        const clickedId = d.id;
                        
                        if (selectedPointIds.includes(clickedId)) {
                            // Remove if already selected
                            selectedPointIds = selectedPointIds.filter(id => id !== clickedId);
                        } else if (selectedPointIds.length < 2) {
                            // Add if less than 2 selected
                            selectedPointIds.push(clickedId);
                        } else {
                            // Replace first selection if 2 already selected
                            selectedPointIds = [selectedPointIds[1], clickedId];
                        }
                        
                        // Update all points across all subplots
                        d3.selectAll(".point")
                            .classed("selected", p => selectedPointIds.includes(p.id))
                            .classed("selected-first", p => selectedPointIds[0] === p.id)
                            .classed("selected-second", p => selectedPointIds[1] === p.id);
                        
                        const selectedPoints = selectedPointIds.map(id => 
                            paretoPoints.find(p => p.id === id)
                        ).filter(p => p !== undefined);
                        
                        updatePolarPlots(selectedPoints.length > 0 ? selectedPoints : null);
                        updateStats(selectedPoints);
                        
                        // Wait for simulation to load
                        await loadSimulation(d);
                        // Set plotting state
                        isPlottingInProgress = true;
                        
                        // Add simulation traces and wait for completion
                        for (let i=0; i<selectedPoints.length; i++){
                            await addSimulationTraceToCharts(simulations_map[selectedPointIds[i]].data, files, dygraphInstances, i+1);
                        }
                        
                        
                        console.log("Selected points:", selectedPointIds);
                        
                    } catch (error) {
                        console.error("Error loading simulation or plotting:", error);
                    } finally {
                        // Reset states
                        isSimulationLoading = false;
                        isPlottingInProgress = false;
                        
                        // Remove loading UI state
                        d3.select(this).classed("loading", false);
                    }
                })
                .on("mouseover", function(event, d) {
                    const colorValue = calculateColorValue(d, colormapping);
                    tooltip.style("opacity", 1)
                        .html(`
                            <strong>This view:</strong><br/>
                            X (${unicode_map[parameters.headers[col + 1]]}): ${d3.format(".1e")(d.objectives[col])}<br/>
                            Y (${unicode_map[parameters.headers[row + 1]]}): ${d3.format(".1e")(d.objectives[row])}<br/>
                            <strong>Colour Value:</strong> ${colorValue.toFixed(3)}
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
        }
        async function loadSimulation(index){
            
            if (simulations_map[index.id].loaded==false){
                let second_idx;
                if (index.id%2==0){
                    second_idx=index.id+1
                }else{
                    second_idx=index.id-1;
                }
                let current_load;
                let idxs=([second_idx, index.id]).sort((a, b) => a - b);
                let cols =[1,2];
                for (let i=0; i<files.length; i++){
                    for (let j=0; j<2; j++){
                        current_load= await loadDataFile(joinPath("M4D2", "simulations", files[i], simulations_map[idxs[j]].file))
                        simulations_map[idxs[j]].data[files[i]]={
                                                                    times:current_load.data.map(row => row[0]),
                                                                    data:current_load.data.map(row=> row[cols[j]])
                                                            };
                        
                        
                        if (files[i].includes("FTACV")){
                            simulations_map[idxs[j]].data[files[i]].harmonics=wasm.harmonics(
                                                                                    simulations_map[idxs[j]].data[files[i]].times,//time
                                                                                    simulations_map[idxs[j]].data[files[i]].data,//current
                                                                                    0.0,//input_freq
                                                                                    true,//envelope
                                                                                    10,//truncation_oscillation
                                                                                    [...Array(6).keys()].map(i => i + 2),//harmonics
                                                                                    25, //filter_pc,
                                                                                    1,//decimation_factor
                                                                                    1/(simulations_map[idxs[j]].data[files[i]].times[1]-simulations_map[idxs[j]].data[files[i]].times[0])
                                                                                ).harmonics;
                            }   
                        }
                    }
                }
            }   
            
        
        function updateColorLegend(colorScale, mapping) {
            const legend = d3.select("#colorLegend");
            legend.selectAll("*").remove();
            
            const legendTitle = legend.append("div")
                .style("font-weight", "600")
                .style("margin-bottom", "10px")
                .text(`Color represents: ${getColorMappingLabel(mapping)}`);
            
            const legendItems = legend.append("div")
                .style("display", "flex")
                .style("gap", "15px")
                .style("flex-wrap", "wrap");
            
            // Create 5 legend items
            for(let i = 0; i < 5; i++) {
                const value = i / 4;
                const color = colorScale(colorScale.domain()[0] + value * (colorScale.domain()[1] - colorScale.domain()[0]));
                
                const item = legendItems.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", color);
                
                const displayValue = colorScale.domain()[0] + value * (colorScale.domain()[1] - colorScale.domain()[0]);
                item.append("span")
                    .text(displayValue.toFixed(3));
            }
        }
        
        function getColorMappingLabel(mapping) {
            const labels = {
                'hypervolume': 'Hypervolume Contribution',
                'distance': 'Distance from Origin',
                'dominance': 'Dominance Score',
                'crowding': 'Crowding Distance',
                'index': 'Point Index'
            };
            
            if(mapping.startsWith('obj')) {
                const objNum = parseInt(mapping.substr(3)) + 1;
                return `Objective ${objNum}`;
            }
            
            return labels[mapping] || mapping;
        }

        function updateStats(selectedPoints) {
            const statsPanel = d3.select("#statsPanel");
            statsPanel.selectAll("*").remove();
            
            // Basic statistics
            const numPoints = paretoPoints.length;
            const avgDistance = d3.mean(paretoPoints, d => 
                Math.sqrt(d.objectives.reduce((sum, obj) => sum + obj * obj, 0))
            );
            
            let selectedPoint = null;
            let cval;
            if(selectedPointIds.length >0) {
                //selectedPoint = paretoPoints.find(p => p.id === selectedPointId);
                    cval = selectedPointIds.map(pointId => {
                    const point = paretoPoints.find(p => p.id === pointId);
                    const scoreObj = { "Selected point": pointId };
                    scores.headers.forEach((score, index) => {
                        scoreObj[score] = calculateColorValue(point, index).toFixed(3);
                    });
                    return scoreObj;
                });
                
            }else{
                cval=[];
            }

            // Create stat items
            const stats = [
                { label: "Total Points", value: numPoints },
                { label: "Objectives", value: numObjectives },
                
            ];
            //{ label: "Selected Point", value: selectedPoint ? `#${selectedPoint.id}` : "None" }
            if (cval.length==1){
                for (let key of Object.keys(cval[0])) {
                    stats.push({label:key, value:cval[0][key]})
                }
            }else if (cval.length>1){
                
                for (let key of Object.keys(cval[0])) {
                        stats.push({label:key, value:`${cval[0][key]} | ${cval[1][key]}`})
                    }
            }

            stats.forEach(stat => {
                const item = statsPanel.append("div")
                    .attr("class", "stat-item");
                
                item.append("div")
                    .attr("class", "stat-value")
                    .text(stat.value);
                
                item.append("div")
                    .attr("class", "stat-label")
                    .text(stat.label);
            });
            
            // If a point is selected, show its detailed info
            if(selectedPointIds.length >0) {
                const detailItem = statsPanel.append("div")
                .attr("class", "stat-item")
                .style("grid-column", "1 / -1");

            const table = detailItem.append("table")
                .attr("class", "objectives-table")
                .style("width", "25%")
                .style("font-size", "0.9em");

            // Create header row
           

            // Create table body
            const tbody = table.append("tbody");
                for (let i = 0; i < numObjectives - 1; i++) {
                    if (format_params.has(parameters.headers[i + 1])) {
                    const row = tbody.append("tr");
                    row.append("td").text(label_map[parameters.headers[i + 1]]);
                    
                    if (selectedPointIds.length > 1) {
                        row.append("td").text(d3.format(".1e")(selectedPoints[0].objectives[i]));
                        row.append("td").text(d3.format(".1e")(selectedPoints[1].objectives[i]));
                    } else {
                        row.append("td").text(d3.format(".1e")(selectedPoints[0].objectives[i]));
                    }
                    } else {
                    const row = tbody.append("tr");
                    row.append("td").text(label_map[parameters.headers[i + 1]]);
                    
                    if (selectedPointIds.length > 1) {
                        row.append("td").text(selectedPoints[0].objectives[i].toFixed(3));
                        row.append("td").text(selectedPoints[1].objectives[i].toFixed(3));
                    } else {
                        row.append("td").text(selectedPoints[0].objectives[i].toFixed(3));
                    }
                    }
                }

                 MathJax.typesetPromise();
            }
            if (d3.select("#data-grid").empty()) {
                createDataGrid("#dataGridContainer");
            }
        }

        // Event listeners
        document.getElementById('colormap').addEventListener('change', updateMatrix);
        document.getElementById('colormapping').addEventListener('change', updateMatrix);

        // Initialize
        generateRandomPoints();
    function createDataGrid(container) {
        const gridContainer = d3.select(container).append("div")
            .attr("class", "data-grid-container")
            .style("margin-top", "20px")
            .style("background", "white")
            .style("border-radius", "15px")
            .style("padding", "20px")
            .style("box-shadow", "0 10px 30px rgba(0, 0, 0, 0.1)");

        gridContainer.append("h3")
            .style("margin-top", "0")
            .style("color", "#667eea")
            .text("Data Grid Visualization");

        const gridSvg = gridContainer.append("div")
            .attr("id", "data-grid")
            .attr("width", "100%");

        return gridSvg;
    }

   

    function createCellVisualization(cellG, width, height, row, col) {
        const margin = { top: 10, right: 10, bottom: 10, left: 10 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        const chartG = cellG.append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        // Generate sample data for each cell
        const numPoints = 20;
        const data = Array.from({ length: numPoints }, (_, i) => ({
            x: (i / (numPoints - 1)) * innerWidth,
            y: Math.random() * innerHeight,
            value: Math.random()
        }));

    // Create a simple scatter plot in each cell
    const colorScale = d3.scaleSequential(d3.interpolateViridis)
        .domain([0, 1]);

    chartG.selectAll(".grid-point")
        .data(data)
        .enter()
        .append("circle")
        .attr("class", "grid-point")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("r", 2)
        .attr("fill", d => colorScale(d.value))
        .attr("opacity", 0.7);

    // Add cell title
    chartG.append("text")
        .attr("x", innerWidth / 2)
        .attr("y", -2)
        .attr("text-anchor", "middle")
        .attr("font-size", "10px")
        .attr("font-weight", "600")
        .attr("fill", "#666")
        .text(`Cell ${row + 1},${col + 1}`);
}
    </script>
</body>
</html>